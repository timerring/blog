[{"id":0,"href":"/blog/posts/2024/deploy-github-pages-with-gpg-signing/","title":"Deploy Github Pages With GPG Signing","section":"Blog","content":"I have been busy migrating my blog this week. Coincidentally, I learned that there may be cases of commit forgery on GitHub. Therefore, for security reasons, I added a GPG signature. However, when deploying Hugo, I encountered many problems regarding whether GPG signatures can also be used. Fortunately, I finally solved them.\nIf you don\u0026rsquo;t know what GPG is, you can read GPG 101.\nHow to Deploy Github Pages With Gpg Signing and Verify # There are two main ways to deploy:\nPush all source files to GitHub directly, then use the relevant action to complete the entire deployment process. Isolate the blog source files from the built files, push the source files to the private repository of GitHub each time, and then set up the relevant workflow in the private repository to push to the public static repository. To ensure greater security, I chose the second method, deploying Hugo in the workflow of GitHub Pages, and using the actions-gh-pages action. However, due to various reasons, the author of this action does not want to add the GPG signature feature. Therefore, we have to solve the problem ourselves.\nImport GPG Key # First, I found a workflow for importing GPG keys on GitHub. After reading the documentation, my own workflow is as follows:\n- name: Import GPG key # import the gpg key to the github action uses: crazy-max/ghaction-import-gpg@v6 # repository https://github.com/crazy-max/ghaction-import-gpg with: # I use the subkey to sign the commit, if you use the primary key, you can refer to his repository docs. gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }} # the secret gpg subkey passphrase: ${{ secrets.PASSPHRASE }} # the passphrase of the gpg subkey git_user_signingkey: true git_commit_gpgsign: true fingerprint: ${{ secrets.FINGERPRINT }} # the fingerprint of the public subkey you use If you only use the primary secret key of GPG, you do not need to add the fingerprint, and I generated a dedicated subkey for signing for security reasons. Therefore, you need to specify the fingerprint of the public key of the subkey. Note that the fingerprint should be entered without spaces; otherwise, it will report an error 67108933 Not implemented \u0026lt;GPG Agent\u0026gt;. I added this note to the corresponding issue.\nDon\u0026rsquo;t forget to fill in the corresponding secret variables and values in the repository.\nDeploy # Since the author does not plan to add GPG signature, we need to clone the project and modify it ourselves. Usually, the -S option is used in the commit to specify the use of GPG signature. Therefore, I found the corresponding function in the commit and added the corresponding -S option.\nNote that the modified workflow you created cannot be used directly. The author\u0026rsquo;s instructions are as follows:\nThis action and my other actions do not provide the branch execution. I add the lib/index.js for only each release commit. After releasing, I delete it.\nTherefore, we still need to publish a version ourselves. Run ./release.sh directly in the project, and publish the version you wrote. After that, you can reference your version in the workflow, and my workflow is as follows:\n- name: Deploy Web uses: timerring/actions-gh-pages@v5.0.0 # this is adjusted action from peaceiris/actions-gh-pages, you can use it directly. with: personal_token: ${{ secrets.PERSONAL_TOKEN }} # the personal token of the github action external_repository: your_username/your_repository # your target repository publish_branch: main # the branch you want to deploy publish_dir: ./public # the directory you want to deploy user_name: ${{ secrets.USER_NAME }} # the name of the github action user_email: ${{ secrets.USER_EMAIL }} # the email of the github action # ATTENTION: please add your github verified email commit_message: ${{ github.event.head_commit.message }} Note that please ensure that you add the email verified by GitHub; otherwise, the default parameter ${process.env.GITHUB_ACTOR}@users.noreply.github.com will only generate USERNAME@users.noreply.github.com, not ID+USERNAME@users.noreply.github.com. This is a historical issue with GitHub, details can be found here. However, your private key does not contain this UUID, so it cannot be verified by GPG. (Even if you add this UID to the keys, since the user email has not been verified by GitHub, it will only display unverified in the end.)\nIn short, if your GitHub account was created after July 18, 2017, then your GitHub email address is ID+USERNAME@users.noreply.github.com, not the default USERNAME@users.noreply.github.com. In this case, you need to specify the user_email parameter and fill in the email address you have verified.\nFinally, after pushing to the blogsource repository, the workflow will automatically deploy to the blog repository, and the commit will be signed with GPG and display verified!\nYou can check my result here, every commit pushed from the blogsource repository will be signed with GPG and display verified.\nAppendix # If you also need my hugo deployment method, you can directly use the action version I modified and released, repository address timerring/actions-gh-pages, refer to my complete workflow yaml, and don\u0026rsquo;t forget to fill in the corresponding secret variables and values:\nname: deploy on: push: branches: - main workflow_dispatch: jobs: build: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v3 with: submodules: true fetch-depth: 0 ref: main - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#34;0.108.0\u0026#34; extended: true - name: Build Web run: hugo --minify - name: Import GPG key # import the gpg key to the github action uses: crazy-max/ghaction-import-gpg@v6 # repository https://github.com/crazy-max/ghaction-import-gpg with: # I use the subkey to sign the commit, if you use the primary key, you can refer to his repository docs. gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }} # the secret gpg subkey passphrase: ${{ secrets.PASSPHRASE }} # the passphrase of the gpg subkey git_user_signingkey: true git_commit_gpgsign: true fingerprint: ${{ secrets.FINGERPRINT }} # the fingerprint of the public subkey you use - name: Deploy Web uses: timerring/actions-gh-pages@v5.0.0 # this is adjusted action from peaceiris/actions-gh-pages, you can use it directly. with: personal_token: ${{ secrets.PERSONAL_TOKEN }} # the personal token of the github action external_repository: your_username/your_repository # your target repository publish_branch: main # the branch you want to deploy publish_dir: ./public # the directory you want to deploy user_name: ${{ secrets.USER_NAME }} # the name of the github action user_email: ${{ secrets.USER_EMAIL }} # the email of the github action # ATTENTION: please add your github verified email commit_message: ${{ github.event.head_commit.message }} "},{"id":1,"href":"/blog/posts/2024/gpg-101/","title":"GPG 101","section":"Blog","content":" GnuPG is a complete and free implementation of the OpenPGP standard as defined by RFC4880(also known as PGP). GnuPG allows you to encrypt and sign your data and communications; it features a versatile key management system, along with access modules for all kinds of public key directories. GnuPG, also known as GPG, is a command line tool with features for easy integration with other applications.\nThis article I will introduce the basic usage of GPG.\nWhat is GPG? # When it comes to GPG, you should know the PGP first. The PGP is a protocol that provides encryption and digital signature services(Pretty Good Privacy). The GPG is the implementation of the PGP protocol. PGP can support many kinds of encryption algorithms, such as AES, RSA, ECC, etc.\nAnd you can add it to your Github to make every commit to your repository is signed.\nDo not upload any message to the public key servers, it\u0026rsquo;s not secure! Do not do any operation related to public key servers! In this article, I will not mention any operation related to public key servers! The public key servers is a centralized service, and will not delete any messages even you have revoked the public key.\nSome abbreviations # Usage # A =\u0026gt; Authentication (eg. ssh) C =\u0026gt; Certify (Only the primary key have this capability) E =\u0026gt; Encrypt S =\u0026gt; Sign (eg. sign the commit) ? =\u0026gt; Unknown capability\nType # sec =\u0026gt; Secret Primary Key ssb =\u0026gt; Secret Subkey pub =\u0026gt; Public Primary Key sub =\u0026gt; Public Subkey\nFormat # armored: asc binary: pgp Fingerprint # Each key or subkey has a line of 10 groups of 4 characters. This is the SHA-1 hash of the entire key, which is 160 bits, 20 bytes, and is usually represented as 40 hexadecimal numbers. This fingerprint can be used to uniquely identify a key pair.\nKey ID # Format:\nLong: the last 16 characters of the fingerprint. Short: the last 8 characters of the fingerprint. UID # UID is the user id which contains the username, comment and email. Name (Comment) \u0026lt;Email\u0026gt;\nOne secret key can have multiple UIDs. UID is used for the whole keys not just for specific subkey. The uid can add easily, but the existing uid cannot be adjusted, only can be revoked. Validity # When import a key, it will default to [unknown]. You can check the fingerprint and the owner\u0026rsquo;s claim to verify the key.\nTrust network # Trust levels:\nultimate: Normally you should only ultimately trust your own keys. The root of the trust chain. full: Full trust the key, also contains the keys signed by this key. marginal: Trust the key, but not fully trust. If three people trust the key, then I trust it. never: Never trust the key along with the keys signed by this key. How to use it? # Installation # brew install gpg Generate Key # You have to do the following steps quickly. If the process is timeout, you will need to re-do the steps.\ngpg --full-generate-key # 1. Then select the key type, it\u0026#39;s fine by default. # 2. Then select the key expiration, I choose `3y`, because you can renew the key later, and that\u0026#39;s make sure you cn still control the key. Expired keys are only invalid for new encryption and signing. But you can still decrypt and verify the existing information, just will be marked as expired. # 3. Then enter you name(uid), I don\u0026#39;t recommend you to use your real name, you can instead of your username. # 4. Then enter your email, make sure to use the verified email in Github, it\u0026#39;s highly recommended to use the `no-reply` email provided by Github to avoid spam. # 5. Then enter the passphrase, it\u0026#39;s used to encrypt the key. # 6. After a rondom move, your key is generated. Generate subkey # It is recommended to generate a subkey for the key. And just use the primary key to sign the new subkeys. Each subkey has its own application scenario.\n# Enter the primary key interactive mode gpg --edit-key yourNameInprimaryKey(uid or keyid) gpg \u0026gt; addkey # Then the process is the same as the previous steps. This time I choose the RSA(sign only). # Btw, before generate the subkey, it will ask you to enter the passphrase of the primary key. # After the subkey is generated, don\u0026#39;t forget to save the key. gpg \u0026gt; save Genrate a revocation certificate # Imagine you forget the passphrase of the key, or you lose the control, you can use the revocation certificate to revoke the public key. If not, you will need to notify your friends that you don\u0026rsquo;t use the key anymore. That will be a big problem. Thus it is necessary to generate a revocation certificate.\ngpg --gen-revoke -ao revoke.pgp uid(or keyid) # Make choices based on your situation Then you will get a revoke.pgp file, you can use it to revoke the key.\nlist the keys # gpg --list-keys # list the public keys, you can also use `gpg -k` gpg --list-secret-keys # list the secret keys, you can also use `gpg -K` The common usage # # The most common usage! -k or -K gpg -K --with-fingerprint --with-subkey-fingerprint --keyid-format long Besides, there are some parameters that you may need to use:\n--with-fingerprint # print the fingerprint of the key --with-subkey-fingerprint # print the fingerprint of the subkey --with-sig-list # print the signature of keys Export the key # gpg -ao public-key.txt --export uid(or keyid) # export the public key # It is better to add your secure path before the secret-key, it will export to the machine directly. gpg -ao secret-key --export-secret-key primarykeyid! # export the primary secret key, remember to add the `!` to export the single key, or you will export the whole secret keys. gpg -ao sign-subkey --export-secret-subkeys subkeyid! # export the sign sub secret key.[S] gpg -ao encrypt-subkey --export-secret-subkeys encryptkeyid! # export the encrypt sub secret key.[E] Most usage # Besides, GPG private key exported as an ASCII armored version or its base64 encoding (often).\ngpg --export-secret-key --armor keyid \u0026gt; secret-key.asc Delete the key # After Export the keys, you can delete then from the machine.\ngpg --delete-secret-keys uid(or keyid) # delete the secret key gpg --delete-keys uid(or keyid) # delete the public key As we know, the keys is stored in the machine in plaintext, it will not delete the keys completely, you can use the wipe or other tools to assist. But there is still the risk of restoring the keys. If you really want to generate and delete the keys in the most secure way, you can try Tails(boum.org).\nImport the key # Strongly discourage any operation related to public key servers!\ngpg --import yourkeysfile(your secret key or others public key) # output # the `#` means the primary key is not imported, so it\u0026#39;s safe. # sec# rsa3072/keyid 2021-01-11 [SC] # ... # the `#` means the subkey is imported. # ssb # rsa3072/keyid 2021-01-11 [E] Sign and verify # # Sign # 1. generate the binary signature file gpg --sign input.txt # 2. generate the ASCII signature file gpg --clearsign input.txt # 3. generate the signature file and original file separately. gpg --armor --detach-sign input.txt # verify gpg --verify input.txt.asc input.txt Encrypt and decrypt # # encrypt # uid(or keyid) is the uid or keyid of the recipient which means you have to import the public key of the recipient in advance. gpg --encrypt --recipient uid(or keyid) input.txt --output output.txt # a simple version gpg -se -o encrypt.txt -r uid(or keyid) input.txt # decrypt gpg --decrypt encrypt.txt --output decrypt.txt Revoke # Even you have revoke the key, if there is still someone sent you message by the outdated public key, you can decrypt the message as well as the hacker can. This operation import the revocation certificate which will make the whole keys invalid. The revoked key is only invalid for new encryption and signing. But you can still decrypt and verify the existing information, but it will be marked as revoked.\nImagine the scenario, Alice\u0026rsquo;s secret key is leaked, she will send a key revocation certificate, but the distribution is not centralized, so she cannot make sure everyone has received the message. Besides, the key revocation certificate is need to be signed by the secret key of the Alice, so if the secret key is lost, she will not be able to revoke the key.\nSo once you have revoked the key, you should push the revoked public key to where you publish the key always, and notify your friends.\n# revoke the primary key # import the public key first gpg --import gpg-linus.asc # then import the revoke certificate which will make the public key invalid directly. gpg --import revoke # gpg -k to check the key is revoked. eg.[revoked: 2024-01-01] # revoke the subkey gpg --edit-key uid(or keyid) # then select the subkey you want to revoke gpg \u0026gt; list gpg \u0026gt; key 1 # 1 is the index of the subkey gpg \u0026gt; revoke gpg \u0026gt; save Config your git # Refer to Github docs and Github docs\nReference # Github docs GnuPG docs ulyc blog Ruanyifeng blog GaoWeiX blog "},{"id":2,"href":"/blog/posts/2024/housewarming-2024/","title":"Housewarming 2024","section":"Blog","content":"So after a long time, I decide to restart my blog program. In my daily development, I have a lot of thoughts and ideas, thus I will write some documents to record them. But I believe that sharing is the best way to learn. A specific example is cryptography, which means the closing source algorithm is never the safest. Only algorithms that have been vetted by the public are truly secure.\nRestart # The reason why I call it restart is that I have been using hexo for a long time, and I wrote the blogs via hexo from the time I entered the university. But there is a serious problem in hexo, which is the deploy speed is too slow. When I have a little blogs, it is not a big problem, but the number of blogs increases with time, the deploy time exceeds 2 minutes, which is unbearable for me and it is hard to check the blog before publishing. And that makes me don\u0026rsquo;t want to publish blogs again, and then I reduced the times of publishing blogs until stopped.\nAfter about 1 year, now I decide to restart it, I came across hugo by chance, and just as the documentation says:\nHugo is a static site generator written in Go, optimized for speed and designed for flexibility. With its advanced templating system and fast asset pipelines, Hugo renders a complete site in seconds, often less.\nSo I finally decide to migrated contents from hexo to hugo.\nMigration # The migration process is smooth. The content types are nearly uniform, so I just need to pay attention to the project structure. And reading the documentation, the hugo mainly contains these parts:\n. ├── archetypes # the template of creating new pages ├── assets # the static files ├── config.toml # the configuration of the blog ├── content # blogs ├── public # hugo build output ├── resources # some resources ├── static # the static files └── themes # the added themes will be here and the theme structure is similar to the main hugo The creation of the blog can be referred to the official documentation.\nThemes # The theme I choose is hugo-book, which is a theme for hugo. Simple and graceful.\nMathematics # For the mathematics, there are two ways in browser to render the formula, the Katex and MathJax. They are all open source javascript libraries. Since I knew the markdown syntax, I use the Typora which supports MathJax library. So I get used to its syntax which accounts for the reason why I choose it.\nDeployment # The deployment is done by github actions, and the workflow file is in the .github/workflows/hugo.yml. BTW, the most contents on the search engine are about the blog deployment in personal github pages, which is not suitable for me, cause the personal github pages is used to store personal homepage. Thus, I will use the private repository blogsource to store the source code and use the blog repository to host the blog.\nAbout the process, I found a toturial at random, you can refer to it. And for more infomation you can refer to the official documentation.\nThere are some key steps to note:\nMake sure the blog repository is public and the Settings -\u0026gt; Pages -\u0026gt; Build and deployment -\u0026gt; Source is set to Deploy from a branch, and the branch is main as well as /(root) is selected.\nGenerate a personal token in github and set it in the blogsource repository. This guarantees you have the permission to operate the target repository.\nSet a deploy.yml file in the .github/workflows directory of blog source code repository which is private. You can refer to this code name: deploy on: push: branches: - main workflow_dispatch: jobs: build: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v3 with: submodules: true fetch-depth: 0 ref: main - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#34;0.108.0\u0026#34; # your hugo version. extended: true - name: Build Web run: hugo --minify - name: Deploy Web uses: peaceiris/actions-gh-pages@v3 with: # Make sure the name is same as what you set in the repo. PERSONAL_TOKEN: ${{ secrets.PERSONAL_TOKEN }} # Set the token in the `blog` repository. EXTERNAL_REPOSITORY: timerring/blogs # Set the target repository. PUBLISH_BRANCH: main PUBLISH_DIR: ./public # Set the publish directory. commit_message: ${{ github.event.head_commit.message }} Add the publishDir = \u0026quot;public\u0026quot; in the config.toml file and set your baseURL according to your target.\nAfter setting these, you can try to push it as normal. You will only need to push the source code to the blogsource repository, and then the blog will be deployed to the blog repository automatically through github actions.\nFonts # From the process of configurate the fonts, I have learned a lot about the fonts.\nStyle # The Style of fonts mainly contains these:\nserif: the fonts with serifs always have a small line at the end of the character. Often used in formal occasions. sans-serif: the fonts focus on simplicity and clarity. Hence it is often used in the web. monospace: the fonts with the same width for all characters. Which is often used in the code display. Weight # Different weights of fonts have different names:\n100 - Thin(Hairline) 200 - Extra Light (Ultra Light) 300 - Light 400 - Regular (Normal,Book,Roman) 500 - Medium 600 - Semi Bold (Demi Bold) 700 - Bold 800 - Extra Bold (Ultra Bold) 900 - Black (Heavy) The Regular and Bold are the most commonly used weights.\nType # The type of fonts mainly contains these:\nttf: TrueType is a font format developed by Apple and Microsoft focusing on the display in the printer in the beginning. otf: OpenType is a extension of TrueType. woff: Web Open Font Format which is a font format compressed to improve the loading speed in web. woff2: Web Open Font Format 2.0. The mostly differ in regard to the compression algorithm. For the fonts part, I have use the production of JetBrains for many years, so I choose the JetBrainsMono-Bold font for the code display.\nAnd for the content part, I use the Helvetica Neue font which is a popular sans-serif font and it is suitable for the web content.\nExtension # In conclusion, I use these extensions in the blog:\ngiscus: the comment system. mathjax: the mathematics system. Google Custom Search Engine: the search system. "},{"id":3,"href":"/blog/docs/about/","title":"About","section":"Docs","content":" About # John Howe GPG Public: 0x26FEE0805E6C9F71 Key fingerprint = B613 FBAF 0822 BEBD FABF 8F65 26FE E080 5E6C 9F71 Coffee chat # blog topic and coffee chat buy me a coffee Where to find me # RSS:source Github:timerring Email: timerring[at]gmail.com Footprints # "},{"id":4,"href":"/blog/docs/friends/","title":"Friends","section":"Docs","content":" Friends links # Me "},{"id":5,"href":"/blog/docs/now/","title":"Now","section":"Docs","content":" Recent # Work on my project bilive. Struggling in Shenzhen Received my Bachelor of Engineering degree from Shandong University Interests # Learning about LLM Inference optimization Nvidia GPU background ffmpeg Addicted to cryptography Objectives # Complete my open source project bilive! Transfer all my blogs to here. Push a tutorial about video and audio codec. Changelog # 2024-12-15 Transfer from hexo to hugo. "}]