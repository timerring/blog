[{"id":0,"href":"/blog/posts/2024/gpg-101/","title":"Gpg 101","section":"Blog","content":" GnuPG is a complete and free implementation of the OpenPGP standard as defined by RFC4880(also known as PGP). GnuPG allows you to encrypt and sign your data and communications; it features a versatile key management system, along with access modules for all kinds of public key directories. GnuPG, also known as GPG, is a command line tool with features for easy integration with other applications.\nThis article I will introduce the basic usage of GPG.\nWhat is GPG? # When it comes to GPG, you should know the PGP first. The PGP is a protocol that provides encryption and digital signature services(Pretty Good Privacy). The GPG is the implementation of the PGP protocol. PGP can support many kinds of encryption algorithms, such as AES, RSA, ECC, etc.\nAnd you can add it to your Github to make every commit to your repository is signed.\nDo not upload any message to the public key servers, it\u0026rsquo;s not secure! Do not do any operation related to public key servers! In this article, I will not mention any operation related to public key servers! The public key servers is a centralized service, and will not delete any messages even you have revoked the public key.\nHow to use it? # Installation # brew install gpg Generate Key # You have to do the following steps quickly. If the process is timeout, you will need to re-do the steps.\ngpg --full-generate-key # 1. Then select the key type, it\u0026#39;s fine by default. # 2. Then select the key expiration, I choose `3y`, because you can renew the key later, and that\u0026#39;s make sure you cn still control the key. # 3. Then enter you name(uid), I don\u0026#39;t recommend you to use your real name, you can instead of your username. # 4. Then enter your email, make sure to use the verified email in Github, it\u0026#39;s highly recommended to use the `no-reply` email provided by Github to avoid spam. # 5. Then enter the passphrase, it\u0026#39;s used to encrypt the key. # 6. After a rondom move, your key is generated. Generate subkey # It is recommended to generate a subkey for the key. And just use the primary key to sign the new subkeys. Each subkey has its own application scenario.\n# Enter the primary key interactive mode gpg --edit-key yourNameInprimaryKey(uid or keyid) gpg \u0026gt; addkey # Then the process is the same as the previous steps. This time I choose the RSA(sign only). # Btw, before generate the subkey, it will ask you to enter the passphrase of the primary key. # After the subkey is generated, don\u0026#39;t forget to save the key. gpg \u0026gt; save Here is the meaning of the abbreviation:\nA =\u0026gt; Authentication (eg. ssh) C =\u0026gt; Certify (Only the primary key have this capability) E =\u0026gt; Encrypt S =\u0026gt; Sign (eg. sign the commit) ? =\u0026gt; Unknown capability sec =\u0026gt; Secret Key ssb =\u0026gt; Secret SuBkey pub =\u0026gt; Public Key sub =\u0026gt; Public Subkey Genrate a revocation certificate # Imagine you forget the passphrase of the key, or you lose the control, you can use the revocation certificate to revoke the public key. If not, you will need to notify your friends that you don\u0026rsquo;t use the key anymore. That will be a big problem. Thus it is necessary to generate a revocation certificate.\ngpg --gen-revoke -ao revoke.pgp uid(or keyid) # Make choices based on your situation Then you will get a revoke.pgp file, you can use it to revoke the key.\nlist the keys # gpg --list-keys # list the public keys, you can also use `gpg -k` gpg --list-secret-keys # list the secret keys, you can also use `gpg -K` The common usage # # The most common usage! -k or -K gpg -K --with-fingerprint --with-subkey-fingerprint --keyid-format long Besides, there are some parameters that you may need to use:\n--with-fingerprint # print the fingerprint of the key --with-subkey-fingerprint # print the fingerprint of the subkey --with-sig-list # print the signature of keys Export the key # gpg -ao public-key.txt --export uid(or keyid) # export the public key # It is better to add your secure path before the secret-key, it will export to the machine directly. gpg -ao secret-key --export-secret-key primarykeyid! # export the primary secret key, remember to add the `!` to export the simple version. gpg -ao sign-subkey --export-secret-subkeys subkeyid! # export the sign sub secret key.[S] gpg -ao encrypt-subkey --export-secret-subkeys encryptkeyid! # export the encrypt sub secret key.[E] Most usage # Besides, GPG private key exported as an ASCII armored version or its base64 encoding (often).\ngpg --export-secret-key --armor keyid \u0026gt; secret-key.asc Delete the key # After Export the keys, you can delete then from the machine.\ngpg --delete-secret-keys uid(or keyid) # delete the secret key gpg --delete-keys uid(or keyid) # delete the public key As we know, the keys is stored in the machine in plaintext, it will not delete the keys completely, you can use the wipe or other tools to assist. But there is still the risk of restoring the keys. If you really want to generate and delete the keys in the most secure way, you can try Tails(boum.org).\nImport the key # Strongly discourage any operation related to public key servers!\ngpg --import yourkeysfile(your secret key or others public key) # output # the `#` means the primary key is not imported, so it\u0026#39;s safe. # sec# rsa3072/keyid 2021-01-11 [SC] # ... # the `#` means the subkey is imported. # ssb # rsa3072/keyid 2021-01-11 [E] Sign and verify # # Sign # 1. generate the binary signature file gpg --sign input.txt # 2. generate the ASCII signature file gpg --clearsign input.txt # 3. generate the signature file and original file separately. gpg --armor --detach-sign input.txt # verify gpg --verify input.txt.asc input.txt Encrypt and decrypt # # encrypt # uid(or keyid) is the uid or keyid of the recipient which means you have to import the public key of the recipient in advance. gpg --encrypt --recipient uid(or keyid) input.txt --output output.txt # a simple version gpg -se -o encrypt.txt -r uid(or keyid) input.txt # decrypt gpg --decrypt encrypt.txt --output decrypt.txt Revoke # Even you have revoke the key, if there is still someone sent you message by the outdated public key, you can decrypt the message as well as the hacker can. This operation import the revocation certificate which will make the whole keys invalid.\nImagine the scenario, Alice\u0026rsquo;s secret key is leaked, she will send a key revocation certificate, but the distribution is not centralized, so she cannot make sure everyone has received the message. Besides, the key revocation certificate is need to be signed by the secret key of the Alice, so if the secret key is lost, she will not be able to revoke the key.\nSo once you have revoked the key, you should push the revoked public key to where you publish the key always, and notify your friends.\n# revoke the primary key # import the public key first gpg --import gpg-linus.asc # then import the revoke certificate which will make the public key invalid directly. gpg --import revoke # gpg -k to check the key is revoked. eg.[revoked: 2024-01-01] # revoke the subkey gpg --edit-key uid(or keyid) # then select the subkey you want to revoke gpg \u0026gt; list gpg \u0026gt; key 1 # 1 is the index of the subkey gpg \u0026gt; revoke gpg \u0026gt; save Config your git # Refer to Github docs and Github docs\nReference # Github docs ulyc blog Ruanyifeng blog "},{"id":1,"href":"/blog/posts/2024/housewarming-2024/","title":"Housewarming 2024","section":"Blog","content":"So after a long time, I decide to restart my blog program. In my daily development, I have a lot of thoughts and ideas, thus I will write some documents to record them. But I believe that sharing is the best way to learn. A specific example is cryptography, which means the closing source algorithm is never the safest. Only algorithms that have been vetted by the public are truly secure.\nRestart # The reason why I call it restart is that I have been using hexo for a long time, and I wrote the blogs via hexo from the time I entered the university. But there is a serious problem in hexo, which is the deploy speed is too slow. When I have a little blogs, it is not a big problem, but the number of blogs increases with time, the deploy time exceeds 2 minutes, which is unbearable for me and it is hard to check the blog before publishing. And that makes me don\u0026rsquo;t want to publish blogs again, and then I reduced the times of publishing blogs until stopped.\nAfter about 1 year, now I decide to restart it, I came across hugo by chance, and just as the documentation says:\nHugo is a static site generator written in Go, optimized for speed and designed for flexibility. With its advanced templating system and fast asset pipelines, Hugo renders a complete site in seconds, often less.\nSo I finally decide to migrated contents from hexo to hugo.\nMigration # The migration process is smooth. The content types are nearly uniform, so I just need to pay attention to the project structure. And reading the documentation, the hugo mainly contains these parts:\n. ├── archetypes # the template of creating new pages ├── assets # the static files ├── config.toml # the configuration of the blog ├── content # blogs ├── public # hugo build output ├── resources # some resources ├── static # the static files └── themes # the added themes will be here and the theme structure is similar to the main hugo The creation of the blog can be referred to the official documentation.\nThemes # The theme I choose is hugo-book, which is a theme for hugo. Simple and graceful.\nMathematics # For the mathematics, there are two ways in browser to render the formula, the Katex and MathJax. They are all open source javascript libraries. Since I knew the markdown syntax, I use the Typora which supports MathJax library. So I get used to its syntax which accounts for the reason why I choose it.\nDeployment # The deployment is done by github actions, and the workflow file is in the .github/workflows/hugo.yml. BTW, the most contents on the search engine are about the blog deployment in personal github pages, which is not suitable for me, cause the personal github pages is used to store personal homepage. Thus, I will use the private repository blogsource to store the source code and use the blog repository to host the blog.\nAbout the process, I found a toturial at random, you can refer to it. And for more infomation you can refer to the official documentation.\nThere are some key steps to note:\nMake sure the blog repository is public and the Settings -\u0026gt; Pages -\u0026gt; Build and deployment -\u0026gt; Source is set to Deploy from a branch, and the branch is main as well as /(root) is selected.\nGenerate a personal token in github and set it in the blogsource repository. This guarantees you have the permission to operate the target repository.\nSet a deploy.yml file in the .github/workflows directory of blog source code repository which is private. You can refer to this code name: deploy on: push: branches: - main workflow_dispatch: jobs: build: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v3 with: submodules: true fetch-depth: 0 ref: main - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#34;0.108.0\u0026#34; # your hugo version. extended: true - name: Build Web run: hugo --minify - name: Deploy Web uses: peaceiris/actions-gh-pages@v3 with: # Make sure the name is same as what you set in the repo. PERSONAL_TOKEN: ${{ secrets.PERSONAL_TOKEN }} # Set the token in the `blog` repository. EXTERNAL_REPOSITORY: timerring/blogs # Set the target repository. PUBLISH_BRANCH: main PUBLISH_DIR: ./public # Set the publish directory. commit_message: ${{ github.event.head_commit.message }} Add the publishDir = \u0026quot;public\u0026quot; in the config.toml file and set your baseURL according to your target.\nAfter setting these, you can try to push it as normal. You will only need to push the source code to the blogsource repository, and then the blog will be deployed to the blog repository automatically through github actions.\nFonts # From the process of configurate the fonts, I have learned a lot about the fonts.\nStyle # The Style of fonts mainly contains these:\nserif: the fonts with serifs always have a small line at the end of the character. Often used in formal occasions. sans-serif: the fonts focus on simplicity and clarity. Hence it is often used in the web. monospace: the fonts with the same width for all characters. Which is often used in the code display. Weight # Different weights of fonts have different names:\n100 - Thin(Hairline) 200 - Extra Light (Ultra Light) 300 - Light 400 - Regular (Normal,Book,Roman) 500 - Medium 600 - Semi Bold (Demi Bold) 700 - Bold 800 - Extra Bold (Ultra Bold) 900 - Black (Heavy) The Regular and Bold are the most commonly used weights.\nType # The type of fonts mainly contains these:\nttf: TrueType is a font format developed by Apple and Microsoft focusing on the display in the printer in the beginning. otf: OpenType is a extension of TrueType. woff: Web Open Font Format which is a font format compressed to improve the loading speed in web. woff2: Web Open Font Format 2.0. The mostly differ in regard to the compression algorithm. For the fonts part, I have use the production of JetBrains for many years, so I choose the JetBrainsMono-Bold font for the code display.\nAnd for the content part, I use the Helvetica Neue font which is a popular sans-serif font and it is suitable for the web content.\nExtension # In conclusion, I use these extensions in the blog:\ngiscus: the comment system. mathjax: the mathematics system. Google Custom Search Engine: the search system. "},{"id":2,"href":"/blog/posts/2024-12/how-to-deploy-github-pages-with-gpg-signing/","title":"How to Deploy Github Pages With Gpg Signing","section":"Blog","content":" 写了一个 github-action 的demo # 如何使用 gpg 签名部署 Github Pages 并验证 # 这周在忙着迁移自己的博客，恰巧知道了在 github 上会存在 commit 伪造的情况，因此安全起见，我添加了 gpg 签名，但是在部署 hugo 时仍然遇到了很多问题。\n部署主要有两种情况：\n直接将所有源文件 push 到 github 上，然后使用相关的 action 自己完成部署的全过程。 将博客源文件与 build 好的文件隔离，每次 push 源文件到 github 的私有仓库里，然后在该私有仓库中设置相关的 workflow 完成向公开的静态仓库 push 的过程。 为了更加安全，我选择了第二种方式，将 hugo 部署在 github pages 上的 workflow 里，需要使用到 actions-gh-pages 这个 action，但是由于种种原因这个 action 的作者并不想添加 gpg 签名的功能。因此，我们只能自己动手丰衣足食。\n导入 gpg 密钥 # 首先我从 github 上搜到了一个导入 gpg 密钥的 workflow，通过阅读文档，我自己使用的 workflow 如下所示：\n- name: Import GPG key uses: crazy-max/ghaction-import-gpg@v6 with: gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }} passphrase: ${{ secrets.PASSPHRASE }} git_user_signingkey: true git_commit_gpgsign: true fingerprint: ${{ secrets.FINGERPRINT }} # the fingerprint of the public subkey you use, if you use primary key, you can delete this line 其中，如果你只是用 gpg 的 primary secret key，则无需添加 fingerprint，安全起见我用主密钥生成了专门用于签名的 subkey，因此需要指定 subkey 对应的 public key 的 fingerprint。注意，填写 fingerprint 时需要删除中间的所有空格，否则会报错 67108933 Not implemented \u0026lt;GPG Agent\u0026gt;，我给对应的 issue 里添加了这个注意事项。\n别忘记在仓库中填写对应的 secret 变量以及值。\n部署 # 由于作者不打算添加 gpg 签名，因此我们需要自己 clone 项目并进行修改。通常在 commit 中使用 -S 选项来指定使用 gpg 签名，因此我找到该 workflow 中 commit 对应的函数，并添加了对应的 -S 选项。\n请注意，自己修改后的 workflow 并不能直接使用，作者说明如下：\nThis action and my other actions do not provide the branch execution. I add the lib/index.js for only each release commit. After releasing, I delete it.\n因此，我们仍需自己发布一个版本，在该项目中直接运行 ./release.sh，并且发布你编写的版本。之后就可以在 workflow 中引用你的版本了，我的 workflow 如下：\n- name: Deploy Web uses: timerring/actions-gh-pages@e47f7a6802418fb6074655ca670367acd945a2df with: personal_token: ${{ secrets.PERSONAL_TOKEN }} external_repository: timerring/blog # your target repository publish_branch: main publish_dir: ./public user_name: \u0026#39;timerring\u0026#39; user_email: \u0026#39;89397553+timerring@users.noreply.github.com\u0026#39; # ATTENTION: 请务必添加你 github 验证的 email，安全起见，我使用验证邮箱后 github 为我生成的邮箱地址。 commit_message: ${{ github.event.head_commit.message }} 注意，请务必添加你 github 验证后的 email，否则由于作者设置的默认参数 ${process.env.GITHUB_ACTOR}@users.noreply.github.com 只会生成 timerring@users.noreply.github.com，但是你的私钥中并没有该 uuid，因此是无法通过 gpg 验证。（即使你在 keys 中添加了该 uuid，由于该用户邮箱并没有经过 github 验证，最后也只会显示 unverified）。\n最后，push 到 blogsource 仓库后，该 workflow 会自动部署在 blog 仓库中，并且 commit 经过了 gpg 的签名显示 verified！\n附件 # 如果你也需要我的部署方法，可以直接使用我修改后发布的 action 版本，参考我完整的 workflow yaml，别忘记填写对应的 secret 变量以及值：\nname: deploy on: push: branches: - main workflow_dispatch: jobs: build: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v3 with: submodules: true fetch-depth: 0 ref: main - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#34;0.108.0\u0026#34; extended: true - name: Build Web run: hugo --minify - name: Import GPG key uses: crazy-max/ghaction-import-gpg@v6 with: gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }} passphrase: ${{ secrets.PASSPHRASE }} git_user_signingkey: true git_commit_gpgsign: true fingerprint: ${{ secrets.FINGERPRINT }} # the fingerprint of the public subkey you use - name: Deploy Web uses: timerring/actions-gh-pages@e47f7a6802418fb6074655ca670367acd945a2df with: personal_token: ${{ secrets.PERSONAL_TOKEN }} external_repository: timerring/blog publish_branch: main publish_dir: ./public user_name: \u0026#39;timerring\u0026#39; user_email: \u0026#39;89397553+timerring@users.noreply.github.com\u0026#39; commit_message: ${{ github.event.head_commit.message }} "},{"id":3,"href":"/blog/docs/about/","title":"About","section":"Docs","content":" About # John Howe Coffee chat # blog topic and coffee chat buy me a coffee Where to find me # RSS:source Github:timerring Email: timerring[at]gmail.com Footprints # "},{"id":4,"href":"/blog/docs/friends/","title":"Friends","section":"Docs","content":" Friends links # Me "},{"id":5,"href":"/blog/docs/now/","title":"Now","section":"Docs","content":" Recent # Work on my project bilive. Struggling in Shenzhen Received my Bachelor of Engineering degree from Shandong University Interests # Learning about LLM Inference optimization Nvidia GPU background ffmpeg Addicted to cryptography Objectives # Complete my open source project bilive! Transfer all my blogs to here. Changelog # 2024-12-15 Transfer from hexo to hugo. "}]